# code transfered from paper "Inferring gene regulatory networks by integrating# ChIP-seq/chip and  transcriptome data via LASSO-type regularization methods"import numpy as np  # include the numpy pacageimport os  # include operating systemimport sysimport csv# import networkx as nx# import matplotlib.pyplot as pltfrom Lassoutliswh import read_inputfrom Lassoutliswh import arrange_resultfrom Thralgrithomwh import HalfThrfrom Thralgrithomwh import HardThrfrom Thralgrithomwh import SoftThrif len(sys.argv) < 3:    sys.exit('Error: at least two input file name are required, \one file name of expression matrix, second file name of TF names')currentpath = os.getcwd()first_arg = sys.argv[1]  # expression file namesecond_arg = sys.argv[2]  # transcription factor file namethird_arg = Nonefourth_arg = 100fifth_arg = currentpathif len(sys.argv) == 4:    third_arg = sys.argv[3]  # golden standard dataelif len(sys.argv) == 5:    third_arg = sys.argv[3]  # golden standard data    fourth_arg = int(sys.argv[4])  # NumberOfEdgeselif len(sys.argv) == 6:    third_arg = sys.argv[3]  # golden standard data    fourth_arg = int(sys.argv[4])  # NumberOfEdges    fifth_arg = sys.argv[5]  # save pathif not ((os.path.exists(fifth_arg)) | (        os.access(os.path.dirname(fifth_arg), os.W_OK))):    print('The path you want to save the result is not accessible,\the save path have been changed to the current path')    fifth_arg = currentpath''' main function '''''' ##############################################'''PAR = {    'exp.mat.file': first_arg, 'tf.names.file': second_arg,    'priors.file': third_arg, 'outputnumber': fourth_arg,    'save.to.dir': fifth_arg}data = read_input(    PAR['exp.mat.file'], PAR['tf.names.file'], PAR['priors.file'])A = data['tf_mat']  # load data to array# Matrix A: log2-transformedNoA = np.linalg.norm(A, ord=2)# L2 norm of the matrix, the largest singular valueAT = A.TAT = np.divide(AT, NoA)A = AT[experiment_num, regulatorgene_num] = AT.shapeMAX_ITERS = 200  # set the stopping number of iterationssequence = np.array([[1]])routine = sequence.shape# the sequence of sparsity levels set in the codeB = data['exp.mat.data']# Matrix B: log2-transformed gene expression fold changes between# control and TF perturbation samples of 19978# target genes in 245 experimentsInitialX = data['priors.data']# Matrix X describes the connections between TFs and targets,# the TF-target connections defined by ChIP-X data were# converted into an initial matrix. Without ChIP-X data as a prior,# the initial x1 was artificially set as 0.# When integrating ChIP-X data, if TF i has binding site around# the gene j promoter within a defined distance, the# PCC between the expression profiles of TF i and gene j was# calculated and assigned on x1(i,j). PCC can be positive# or negative, representing the TF can activate or# repress the target gene expression.[targetgene_num, experiment_num] = B.shapeFHalf = np.full((targetgene_num, 1), 1, dtype=float)FHard = np.full((targetgene_num, 1), 1, dtype=float)FSoft = np.full((targetgene_num, 1), 1, dtype=float)# records the histroies of error norm(Ax-b) for L1/2,L0 and L1cwd = os.getcwd()  # get current pathti = 0XhalfThr = np.full((regulatorgene_num, targetgene_num), 0, dtype=float)XhardThr = np.full((regulatorgene_num, targetgene_num), 0, dtype=float)XsoftThr = np.full((regulatorgene_num, targetgene_num), 0, dtype=float)# while ti <= routine[1] - 1:  # recursion by the sparsity sequences = float(sequence[ti])for i in range(0, targetgene_num):        b = B[i, :]        b = np.divide(b, NoA)        x1 = InitialX[i, :]        x1 = x1.T# read the files B.txt and IntialX.txt line by line        [xhalf, hist1] = HalfThr(A, b, x1, MAX_ITERS, regulatorgene_num, s)# the iterative half thresholding algorithm for L1/2 regularization,# starting at the initial point x1        FHalf[i] = hist1[-1]        np.savetxt('test.txt', xhalf, fmt='%.4g', delimiter=',', newline='\n')        # np.savetxt(creatpath+'/xHalf.txt', x,fmt='%g', delimiter=' ')        XhalfThr[:, i] = xhalf# the iterative hard thresholding algorithm for L0 regularization,# starting at the initial point x1        [xhard, hist2] = HardThr(A, b, x1, MAX_ITERS, regulatorgene_num, s)        FHard[i] = hist2[-1]        XhardThr[:, i] = xhard# the iterative soft thresholding algorithm for L1 regularization,# starting at the initial point x1        [xsoft, hist3] = SoftThr(A, b, x1, MAX_ITERS, regulatorgene_num, s)        FHard[i] = hist3[-1]        XsoftThr[:, i] = xsoftrelationshalfThr = []for i in range(0, len(data['tf.names'])):    tf1 = []    tfname = data['tf.names'][i]    for j in range(0, XhalfThr.shape[1]):        beta1 = XhalfThr[:, j]        gene1 = data['exp.mat.allgenename'][j]        if beta1[i] != 0:            relation1 = [tfname, gene1, beta1[i]]            tf1.append(relation1)    relationshalfThr.append(tf1)relationshardThr = []for i in range(0, len(data['tf.names'])):    tf1 = []    tfname = data['tf.names'][i]    for j in range(0, XhardThr.shape[1]):        beta1 = XhardThr[:, j]        gene1 = data['exp.mat.allgenename'][j]        if beta1[i] != 0:            relation1 = [tfname, gene1, beta1[i]]            tf1.append(relation1)    relationshardThr.append(tf1)relationssoftThr = []for i in range(0, len(data['tf.names'])):    tf1 = []    tfname = data['tf.names'][i]    for j in range(0, XsoftThr.shape[1]):        beta1 = XsoftThr[:, j]        gene1 = data['exp.mat.allgenename'][j]        if beta1[i] != 0:            relation1 = [tfname, gene1, beta1[i]]            tf1.append(relation1)    relationssoftThr.append(tf1)# -------------------- Save halfThr--------------------#pathsave = PAR['save.to.dir'] + '/results'if not os.path.exists(pathsave):    os.makedirs(pathsave)  # create folderos.chdir(pathsave)relationshalfThrorder, rankhalf = arrange_result(relationshalfThr)if len(relationshalfThrorder) < PAR['outputnumber']:    PAR['outputnumber'] = len(relationshalfThrorder)relationshalfThrorder = list(    relationshalfThrorder[i] for i in range(0, PAR['outputnumber']))rankhalf = rankhalf[0:PAR['outputnumber']]with open('halfThr' + '.csv', 'w') as myfile:    wr = csv.writer(myfile, quoting=csv.QUOTE_NONE)    ii = ['regulator', '    ' + 'target', '    ' + 'score', '    ' + 'rank']    wr.writerow(ii)    for i in range(0, len(relationshalfThrorder)):        rel1 = relationshalfThrorder[i]        ii = [rel1[0], '    ' + rel1[1], '   \         ' + str(rel1[2]), '   ' + str(i + 1)]        wr.writerow(ii)myfile.close()# -------------------- Save hardThr--------------------#pathsave = PAR['save.to.dir'] + '/results'relationshardThrorder, rankhard = arrange_result(relationshardThr)if len(relationshalfThrorder) < PAR['outputnumber']:    PAR['outputnumber'] = len(relationshalfThrorder)relationshardThrorder = list(    relationshardThrorder[i] for i in range(0, PAR['outputnumber']))rankhard = rankhard[0:PAR['outputnumber']]with open('hardThr' + '.csv', 'w') as myfile:    wr = csv.writer(myfile, quoting=csv.QUOTE_NONE)    ii = ['regulator', '    ' + 'target', '    ' + 'score', '    ' + 'rank']    wr.writerow(ii)    for i in range(0, len(relationshardThrorder)):        rel1 = relationshardThrorder[i]        ii = [rel1[0], '    ' + rel1[1], '   \         ' + str(rel1[2]), '   ' + str(i + 1)]        wr.writerow(ii)myfile.close()# --------------------- Save to softThr-------------------#pathsave = PAR['save.to.dir'] + '/results'relationssoftThrorder, ranksoft = arrange_result(relationssoftThr)if len(relationshalfThrorder) < PAR['outputnumber']:    PAR['outputnumber'] = len(relationshalfThrorder)relationssoftThrorder = list(    relationssoftThrorder[i] for i in range(0, PAR['outputnumber']))ranksoft = ranksoft[0:PAR['outputnumber']]with open('softThr' + '.csv', 'w') as myfile:    wr = csv.writer(myfile, quoting=csv.QUOTE_NONE)    ii = ['regulator', '    ' + 'target', '    ' + 'score', '    ' + 'rank']    wr.writerow(ii)    for i in range(0, len(relationssoftThrorder)):        rel1 = relationssoftThrorder[i]        ii = [rel1[0], '    ' + rel1[1], '   \         ' + str(rel1[2]), '   ' + str(i + 1)]        wr.writerow(ii)myfile.close()# tf1rel = relationssoftThr[0]# max_num = 10# if len(tf1rel) > max_num:#    tf1rel = tf1rel[0: max_num]# G = nx.Graph()# tfname = tf1rel[0][0]# G.add_node(tfname)# edge_color = []# labels = {}# labels[0] = tfname# ind = 1# for i in tf1rel:#    gene1 = i[1]#    weight = round(float(i[2]), 2)#    if weight > 0:#        colr = 'red'#    else:#        colr = 'blue'#    edge_color.append(colr)#    labels[ind] = gene1#    G.add_edge(tfname, gene1, weight=round(i[2], 2), color=colr)#    ind = ind + 1# edge_labels =# dict([((u, v, ), d['weight']) for u, v, d in G.edges(data=True)])# pos = nx.spring_layout(G)# nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=14)# nx.draw(G, pos, node_color='white', edge_color=edge_color,#        width=2, with_labels=True, font_size=14)# plt.show()