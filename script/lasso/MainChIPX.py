# code transfered from paper "Inferring gene regulatory networks by integrating# ChIP-seq/chip and  transcriptome data via LASSO-type regularization methods"import numpy as np  # include the numpy pacageimport os  # include operating systemimport csvimport networkx as nximport matplotlib.pyplot as pltfrom Lassoutliswh import read_inputfrom Thralgrithomwh import HalfThrfrom Thralgrithomwh import HardThrfrom Thralgrithomwh import SoftThr###### change the path to the folder containing the code and the data,os.chdir("/Users/Craftsman/Documents/Wei He/Blacksburg/Study/2017\ spring/course/Problem Solving GBCB 5874/project/RegulatoryNetwork/script/\lasso")''' main function '''''' ##############################################'''currentpath = os.getcwd()PAR = {'input.dir': '/Users/Craftsman/Documents/Wei He/Blacksburg/Study/2017\ spring/course/Problem Solving GBCB 5874/project/RegulatoryNetwork/script/\lasso/',  ###### change the path to the folder containing the code and the data,                    'exp.mat.file':                    'GSE10670_ave_TopVar.csv',                    'tf.names.file': 'tfs.csv',                    'priors.file': 'golddata.csv',                    'save.to.dir': currentpath}data = read_input(    PAR['input.dir'], PAR['exp.mat.file'],    PAR['tf.names.file'], PAR['priors.file'])A = data['tf_mat']  # load data to array# Matrix A: log2-transformedNoA = np.linalg.norm(A, ord=2)# L2 norm of the matrix, the largest singular valueAT = A.TAT = np.divide(AT, NoA)A = AT[experiment_num, regulatorgene_num] = AT.shapeMAX_ITERS = 200  # set the stopping number of iterationssequence = np.array([[1]])routine = sequence.shape# the sequence of sparsity levels set in the codeB = data['exp.mat.data']# Matrix B: log2-transformed gene expression fold changes between# control and TF perturbation samples of 19978# target genes in 245 experimentsInitialX = data['priors.data']# Matrix X describes the connections between TFs and targets,# the TF-target connections defined by ChIP-X data were# converted into an initial matrix. Without ChIP-X data as a prior,# the initial x1 was artificially set as 0.# When integrating ChIP-X data, if TF i has binding site around# the gene j promoter within a defined distance, the# PCC between the expression profiles of TF i and gene j was# calculated and assigned on x1(i,j). PCC can be positive# or negative, representing the TF can activate or# repress the target gene expression.[targetgene_num, experiment_num] = B.shapeFHalf = np.full((targetgene_num, 1), 1, dtype=float)FHard = np.full((targetgene_num, 1), 1, dtype=float)FSoft = np.full((targetgene_num, 1), 1, dtype=float)# records the histroies of error norm(Ax-b) for L1/2,L0 and L1cwd = os.getcwd()  # get current pathti = 0XhalfThr = np.full((regulatorgene_num, targetgene_num), 0, dtype=float)XhardThr = np.full((regulatorgene_num, targetgene_num), 0, dtype=float)XsoftThr = np.full((regulatorgene_num, targetgene_num), 0, dtype=float)# while ti <= routine[1] - 1:  # recursion by the sparsity sequences = float(sequence[ti])for i in range(0, targetgene_num):        b = B[i, :]        b = np.divide(b, NoA)        x1 = InitialX[i, :]        x1 = x1.T# read the files B.txt and IntialX.txt line by line        [xhalf, hist1] = HalfThr(A, b, x1, MAX_ITERS, regulatorgene_num, s)# the iterative half thresholding algorithm for L1/2 regularization,# starting at the initial point x1        FHalf[i] = hist1[-1]        np.savetxt('test.txt', xhalf, fmt='%.4g', delimiter=',', newline='\n')        # np.savetxt(creatpath+'/xHalf.txt', x,fmt='%g', delimiter=' ')        XhalfThr[:, i] = xhalf# the iterative hard thresholding algorithm for L0 regularization,# starting at the initial point x1        [xhard, hist2] = HardThr(A, b, x1, MAX_ITERS, regulatorgene_num, s)        FHard[i] = hist2[-1]        XhardThr[:, i] = xhard# the iterative soft thresholding algorithm for L1 regularization,# starting at the initial point x1        [xsoft, hist3] = SoftThr(A, b, x1, MAX_ITERS, regulatorgene_num, s)        FHard[i] = hist3[-1]        XsoftThr[:, i] = xsoftrelationshalfThr = []for i in range(0, len(data['tf.names'])):    tf1 = []    tfname = data['tf.names'][i]    for j in range(0, XhalfThr.shape[1]):        beta1 = XhalfThr[:, j]        gene1 = data['exp.mat.allgenename'][j]        if beta1[i] != 0:            relation1 = [tfname, gene1, beta1[i]]            tf1.append(relation1)    relationshalfThr.append(tf1)relationshardThr = []for i in range(0, len(data['tf.names'])):    tf1 = []    tfname = data['tf.names'][i]    for j in range(0, XhardThr.shape[1]):        beta1 = XhardThr[:, j]        gene1 = data['exp.mat.allgenename'][j]        if beta1[i] != 0:            relation1 = [tfname, gene1, beta1[i]]            tf1.append(relation1)    relationshardThr.append(tf1)relationssoftThr = []for i in range(0, len(data['tf.names'])):    tf1 = []    tfname = data['tf.names'][i]    for j in range(0, XsoftThr.shape[1]):        beta1 = XsoftThr[:, j]        gene1 = data['exp.mat.allgenename'][j]        if beta1[i] != 0:            relation1 = [tfname, gene1, beta1[i]]            tf1.append(relation1)    relationssoftThr.append(tf1)# -------------------- Save halfThr--------------------#pathsave = PAR['save.to.dir'] + '/result1' + '/halfThr'if not os.path.exists(pathsave):    os.makedirs(pathsave)  # create folderos.chdir(pathsave)for i in range(0, len(data['tf.names'])):    if os.path.isfile(data['tf.names'][i] + '.csv'):        os.remove(data['tf.names'][i] + '.csv')    with open(data['tf.names'][i] + '.csv', 'w') as myfile:        wr = csv.writer(myfile, quoting=csv.QUOTE_NONE)        for i in relationshalfThr[i]:            ii = [i[0], '    ' + i[1], '    ' + str(i[2])]            wr.writerow(ii)    myfile.close()# -------------------- Save hardThr--------------------#pathsave = PAR['save.to.dir'] + '/result1' + '/hardThr'if not os.path.exists(pathsave):    os.makedirs(pathsave)  # create folderos.chdir(pathsave)for i in range(0, len(data['tf.names'])):    if os.path.isfile(data['tf.names'][i] + '.csv'):        os.remove(data['tf.names'][i] + '.csv')    with open(data['tf.names'][i] + '.csv', 'w') as myfile:        wr = csv.writer(myfile, quoting=csv.QUOTE_NONE)        for i in relationshardThr[i]:            ii = [i[0], '    ' + i[1], '    ' + str(i[2])]            wr.writerow(ii)    myfile.close()# --------------------- Save to softThr-------------------#pathsave = PAR['save.to.dir'] + '/result1' + '/softThr'if not os.path.exists(pathsave):    os.makedirs(pathsave)  # create folderos.chdir(pathsave)for i in range(0, len(data['tf.names'])):    if os.path.isfile(data['tf.names'][i] + '.csv'):        os.remove(data['tf.names'][i] + '.csv')    with open(data['tf.names'][i] + '.csv', 'w') as myfile:        wr = csv.writer(myfile, quoting=csv.QUOTE_NONE)        for i in relationssoftThr[i]:            ii = [i[0], '    ' + i[1], '    ' + str(i[2])]            wr.writerow(ii)    myfile.close()tf1rel = relationssoftThr[0]max_num = 10if len(tf1rel) > max_num:    tf1rel = tf1rel[0: max_num]G = nx.Graph()tfname = tf1rel[0][0]G.add_node(tfname)edge_color = []labels = {}labels[0] = tfnameind = 1for i in tf1rel:    gene1 = i[1]    weight = round(float(i[2]), 2)    if weight > 0:        colr = 'red'    else:        colr = 'blue'    edge_color.append(colr)    labels[ind] = gene1    G.add_edge(tfname, gene1, weight=round(i[2], 2), color=colr)    ind = ind + 1edge_labels = dict([((u, v, ), d['weight']) for u, v, d in G.edges(data=True)])pos = nx.spring_layout(G)nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=14)nx.draw(G, pos, node_color='white', edge_color=edge_color,        width=2, with_labels=True, font_size=14)plt.show()